# 202130217 양하진     

# 5월 22일 (12주차)

## 프로젝트에 도입하기 (Installation)
- React는 **점진적으로 적용할 수 있도록 설계**되었으며, **필요한 만큼 React를 사용**할 수 있습니다.

## React 시도하기
- local에서 사용해보고 싶다면 Node.js만 설치하면 됩니다.
- 직접 편집하거나 오른쪽 상단의 "Fork(포크)" 버튼을 눌러 새 탭에서 열 수 있습니다.
- React 문서의 대부분 페이지에는 이와 같은 샌드박스가 있습니다.
- React 문서 외에도 CodeSandbox, StackBlitz, CodePen 등의 온라인 샌드박스에서 React를 지원합니다.

## 새로운 React 앱 만들기
- 풀스택 프레임워크 :      
- 권장 프레임워크는 프로덕션에서 앱을 배포하고 확장하는 데 필요한 모든 기능을 지원합니다.
- 최신 React 기능을 통합하고 React의 아키텍처를 활용합니다.
- Next.js (앱 라우터)
- Next.js의 앱 라우터는 React의 아키텍처를 최대한 활용하여 **풀 스택 React 앱을 활성화**하는 React 프레임워크 입니다.
- Next.js는 **Vercel**에서 유지 관리합니다.
- Next.js 앱을 빌드해서 **Node.js와 서버리스 호스팅 혹은 자체 서버에 배포**할 수 있습니다.
- Next.js는 또한 **서버가 필요 없는 정적 내보내기도 지원**합니다.
- Vercel은 추가적으로 옵트-인 **유료 클라우드 서비스도 지원**합니다.     
** Opt-in이란 사용자가 옵션을 직접 선택할 수 있도록 하는 서비스입니다.

- React Router(v7)
- React Router는 **React에서 가장 인기있는 라우팅 라이브러리**이며, **Vite와 함께 사용하면 풀스택 React 프레임워크를 만들 수 있습니다.**
- **표준 Web API**이며, **다양한 자바스크립트 런타임과 플랫폼을 위한 준비된 배포 템플릿**이 있다고 강조합니다.
- React Router는 **Shopify**에서 유지 관리합니다.
- Expo (네이티브 앱용)
- Expo는 **네이티브 UI를 사용하여 안드로이드, ios, 웹을 위한 범용 앱을 만들 수** 있는 React 프레임워크입니다.
- **네이티브 부분을 쉽게 사용할 수 있게 해주는 React Native SDK를 제공**합니다.
- Expo는 **Expo(the company)**에서 유지 관리합니다.     
- TanStack Start (Beta) : TanStack Start는 TanStack Router를 기반으로 하는 풀스택 React 프레임워크입니다. Nitro 나 Vite와 같이 전체 문서 SSR, 스트리밍, 서버 함수, 번들링과 많은 유용한 도구를 제공합니다.
- RedwoodJS : Redwood는 쉽게 풀스택 웹 애플리케이션을 만들 수 있도록 사전탑재된 패키지와 구성을 가진 풀스택 React 프레임워크입니다.     
### [Vite]
- Vite는 현대 웹 프로젝트에 더 빠르고, 가벼운 개발 환경을 제공하는 것을 목표로 하는 빌드 도구입니다.
- Vite는 독창적이며, 기본적으로 합리적인 기본 기능을 제공합니다.
- Vite는 빠른 새로고침, JSX, Babel/SWC 및 기타 일반적인 기능을 지원하는 풍부한 플러그인 생태계를 갖추고 있습니다.

### [Parcel]
- Parcel은 뛰어난 기본 개발 경험과 확장 가능한 아키텍처를 결합하여 프로젝트를 시작 단계에서 대규모 프로덕션 애플리케이션으로 발전시킬 수 있습니다.
- Parcel은 빠른 새로고침, JSX, TypeScript, Flow 및 스타일링을 기본적으로 지원합니다.

### [Rsbuild]
- Rsbuild는 React 애플리케이션 개발에 원활한 환경을 제공하는 Rspack 기반 빌드 도구입니다.
- 세심하게 조정된 기본 설정과 성능 최적화 기능을 바로 사용할 수 있도록 제공합니다.
- Rsbuild는 빠른 새로고침, JSX, TypeScript, 스타일링 등 React 기능을 기본적으로 지원합니다.

### [Routing]
- 라우팅은 사용자가 **특정 URL을 방문할 때 표시할 콘텐츠나 페이지를 결정**합니다.
- 앱의 여러 부분에 **URL을 매핑하려면 라우터를 설정**해야 합니다.
- 또한 **중첩된 경로, 경로 매개변수, 쿼리 매개변수도 처리**해야 합니다.
- 라우터는 코드 내에서 구성하거나 구성 요소 폴더 및 파일 구조에 따라 정의할 수 있습니다.

### [Data Fetching] 데이터 미리 가져오기
- 서버나 다른 데이터 소스에서 **데이터를 미리 가져오는 것**으로 대부분의 애플리케이션에서 **핵심적인 부분**입니다.
- 이를 제대로 수행하려면 **로딩 상태, 오류 상태, 그리고 가져온 데이터를 캐싱 등 복잡한 기능이 포함**됩니다.

### [Code-splitting] 코드 분할
- 코드 분할은 앱을 필요에 따라 로드할 수 있는 작은 묶음으로 나누는 프로세스입니다.
- 앱 전체의 코드를 전송해야 사용하기 때문에 앱 로드 속도가 느려질 수 있습니다.
- Parcel은 React.lazy를 사용하여 코드 분할을 지원합니다. 

# 5월 15일 (11주차)

## 최소한의 데이터만 이용해서 완벽하게 UI State 표현하기     
1. 제품의 원본 목록은 props로 전달되었기 때문에 state가 아닙니다.     
2. 사용자가 입력한 검색어는 시간이 지남에 따라 변하고, 다른 요소로부터 계산될 수 없기 때문에 state로 볼 수 있습니다.
3. 체크박스의 값은 시간에 따라 바뀌고 다른 요소로부터 계산될 수 없기 때문에 state로 볼 수 있습니다.
4. 필터링된 제품 목록은 원본 제품 목록을 받아서 검색어와 체크박스의 값에 따라 계산할 수 있으므로, 이는 state가 아닙니다. 
- 따라서 검색어와 체크박스의 값만이 state입니다.

- React는 항상 컴포넌트 계층구조를 따라 부모에서 자식으로 데이터를 전달하는 단방향 데이터 흐름을 사용하는 것을 기억하세요
- 앱을 구현하면서 어떤 컴포넌트가 state를 가져야 하는 지 바로 명확하지 않을 수 있음.


# 5월 8일 (10주차)

## React로 사고하기
- React를 사용하게 되면 우리가 고려하고 있는 **디자인이나 만들 앱들에 대한 생각을 바꿀 수** 있습니다. 
- React로 사용자 인터페이스를 빌드할 때, 먼저 이를 **컴포넌트라는 조각**으로 나눕니다.
- 그리고 **각 컴포넌트의 다양한 시각적 상태들을 정의**합니다.
- 마지막으로 **컴포넌트들을 연결하여 데이터가 그 사이를 흘러가게** 합니다.
- React는 component 기반으로 개발합니다.    

## UI를 컴포넌트 계층으로 쪼개기
1. FilterableProductTable(회색) : 예시 전체를 포괄합니다.
2. SearchBar(라벤더색) : 데이터 리스트를 보여주고, 사용자의 입력을 기반으로 필터링합니다.
3. ProductCategoryRow(초록색) : 각 카테고리의 헤더를 보여줍니다.
4. ProductRow(노란색) : 각각의 제품에 해당하는 행을 보여줍니다.

## Step 2에 있는 component 구현하기
1. Project를 새로 생성하거나, 초기 commit으로 switch하여 실행에 이상이 없는지 확인합니다.
2. src/ 아래 필요 없는 파일을 제거합니다. (logo.svg/ setupTest.js)
3. App.js에 있는 코드를 모두 삭제합니다.
4. 먼저 다음 코드로 App.js가 정상적으로 동작하는지 확인합니다.
5. 사용할 데이터 PRODUCTS를 적당한 위치에 작성합니다

## Step 3 : 최소한의 데이터만 이용해서 완벽하게 UI State 표현하기
- UI를 **상호작용(interactive)**하게 만들려면, **사용자가 기반 데이터 모델을 변경할 수 있게** 해야 합니다.
- React는 **state를 통해 기반 데이터 모델을 변경**할 수 있게 합니다.
- state는 앱이 기억해야 하는, **변경할 수 있는 데이터의 최소 집합이라고 생각**하세요.
- state를 구조화 하는데 가장 **중요한 원칙은 중복배제원칙**입니다.
- 애플리케이션이 필요로 하는 **가장 최소한의 state를 파악**하고, **나머지 모든 것들은 필요에 따라 실시간으로 계산**하세요.


# 4월 18일 (8주차)

## 과거 움직임 보여주기

- 이제 틱택토 게임의 히스토리를 기록하기 때문에, 플레이어에게 과거 플레이 목록을 보여줄 수 있습니다.

- <button>과 같은 React 엘리먼트는 일반 JavaScript 객체이므로 애플리케이션에서 전달할 수 있습니다.

- React에서 여러 엘리먼트를 렌더링하려면 React 엘리먼트 배열을 사용할 수 있습니다.

- 이미 state에 이동 history 배열이 있기 때문에 이것을 React 엘리먼트 배열로 변환해야 합니다.

- JavaScript에서 한 배열을 다른 배열로 변환하려면 배열 map 메서드를 사용하면 됩니다.    

1. 플레이 history 배열을 화면의 버튼을 나타내는 React 엘리먼트로 변환합니다.

2. 과거의 플레이로 "점프"할 수 있는 버튼 목록을 표시하세요.

3. 이 것을 구현하기 위해서 Game 컴포넌트에서 history를 map을 이용해보겠습니다.

## map 함수의 사용
- map의 기본 구문은 map(callbackFn) 혹은 map(callbackFn, thisArg) 입니다.

- thisArg는 내부에서 this로 사용할 값을 지정하는데 화살표 함수에서는 생략됩니다.

- 따라서 예제에서는 callbackFn만 사용하고, 화살표 함수가 callback 함수를 대신합니다.

- squares, move는 화살표 함수의 매개변소 입니다.

1. history.map: history는 모든 플레이를 저장하는 배열입니다.    이 history에 map함 수를 적용한다는 의미 입니다.

2. map함수는 history 각각의 요소 index를 순회하면서 squares 추출합니다.

3. 각 요소는 土가안의 실행문을 실행하면서 버튼을 생성합니다.

4. 이렇게 생성된 버튼은 moves 객체(배열)에 다시 저장됩니다.

5. move는 최종 rendering에 사용됩니다.

- 원본 배열 (history) : map이 호출된 원본 배열.
- 원본 배열의 인덱스 (move) : 현재 순환 중인 원본 배열 요소의 인덱스.
- 요소 값 (squares) : 현재 순회 중인 요소 배열의 값.

- **moves 객체에 저장**합니다.
- **최종 출력**에 사용합니다.

## key 선택하기
- 리스트가 다시 렌더링 되면 React는 각 리스트 항목의 key를 가져와서 이전 리스트의 항목에서 일치하는 key를 탐색합니다.

- 현재 리스트에서 의전에 존재하지 않았던 key가 있으면 React는 컴포넌트를 생성합니다.

- 만약 현재 리스트에 이전 리스트에 존재했던 key를 가지고 있지 않다면 React는 그 key를 가진 컴포너트를 제거합니다.

- 두 key가 일치한다면 해당 컴포넌트는 이동합니다.

- key는 갈 React가 각 컴포너트를 구별할 수 있도록 하여, 컴포넌트가 다시 렌더링 될 때 React가 해당 컴포넌트의 state를 유지할 수 있게 합니다.

- 컴포넌트의 key가 변하면 컴포너트는 제거되고 새로운 state와 함께 다시 생성됩니다.

- key는 React에서 **특별하게 미리 지정된 프로퍼티**입니다.

- 엘리먼트가 생성되면 React는 key 프로퍼티를 추출하여 **반환되는 엘리먼트에 직접 key를 저장**합니다.

- key가 props로 전달되는 것처럼 보일 수 있지만, React는 **자동으로 key를 사용해 업데이트할 컴포넌트를 결정**합니다.

- **부모가 지정한 key가 무엇인지 컴포넌트는 알 수 없습니다.**

- **동적인 리스트를 만들 때마다 적절한 key를 할당하는 것을 강력하게 추천**합니다.

- 적절한 **key가 없는 경우 데이터의 재구성을 고려**해 보세요.

- **key가 지정되지 않은 경우**, React는 **경고를 표시**하며 **배열의 인덱스를 기본 key로 사용**합니다.

- **배열 인덱스를 key로 사용하면** 리스트 **항목의 순서를 바꾸거나 항목을 추가/제거할 때 문제가 발생**합니다.

- **명시적으로 key={i}나를 전달하면 경고는 사라지지만** 배열의 인덱스를 사용할 때와 같은 문제가 발생하므로 대부분은 **추천하지 않습니다.**


# 4월 17일 (7주차)

## state 끌어올리기
- 이제 Board가 모든 state 를 관리하므로 부모 Board 컴포넌트는 자식 Square 컴포넌트가 올바르게 표시될 수 있도록 props를 전달합니다.
- Square를 클릭하면 자식 Square 컴포넌트가 부모 Board 컴포넌트에 Board의 state를 업데이트하도록 요청합니다.
- Board의 state가 변경되면 Board 컴포넌트와 모든 자식 Square 컴포넌트가 자동으로 다시 렌더링 됩니다.
- Board 컴포넌트에 속한 모든 Square의 state를 유지하면 나중에 승자를 결정할 수 있습니다. 

- 사용자가 Board의 원쪽 위 사각형을 클린하여 X를 추가하면 어떤 일이 발생하는지 다시 한번 정리해 보겠습니다.

1. 왼쪽 위 사각형을 클릭하면 button이 Square로부터 onClick _prop으로 받은 함수가 실행됩니다.

← Square 컴포넌트는 Board에서 해당 함수를 onSquareClick props로 받았습니다.   
← Board 컴포넌트는 JSX에서 해당 함수를 직접 정의했습니다.    
← 이 함수는 0을 인수로 handleClick을 호출합니다.   

2. handleClick은 인수 0을 사용하여 squares 배열의 첫 번째 엘리먼트를 null에서 X로 업데이트합니다.

3. Board 컴포넌트의 squares state가 업데이트되어 Board와 그 모든 자식이 다시 렌더링 됩니다.   
→ 이에 따라 인덱스가 0인 Square 컴포넌트의 value prop이 null에서 X로 변경됩니다.

4. 최종적으로 사용자는 왼쪽 위 사각형을 클릭한 후 비어 있는 사각형이 X로 변경된 것을 확인할 수 있습니다.    

- DOM <button> 엘리먼트의 onClick 어트리뷰트(속성)는 빌트인 컴포넌트이기 때문에 React에서 특별한 의미를 갖습니다.

- 사용자 정의 컴포넌트, 예를 들어 Square의 경우 이름은 사용자가 원하는 대로 지을 수 있습니다.

- Square의 onSquareClick prop나 Board의 handleClick 함수에 어떠한 이름을 붙여도 코드는 동일하게 작동합니다.

- React에서는 주로 이벤트를 나타내는 prop에는 onSomething과 같은 이름을 사용하고, 이벤트를 처리하는 함수를 정의 할 때는 handleSomething과 같은 이름을 사용합니다.

## 불변성이 왜 중요할까요
- handleClick에서 기존 배열을 수정하는 대신 slice()를 호출하여 squares 배열의 사본을 생성하는 방법에 주목하세요.
- 그 이유를 설명하기 위해 불변성과 불변성을 배우는 것이 중요한 이유에 대해 논의해보겠습니다.
- 일반적으로 데이터를 변경하는 방법에는 두 가지가 있습니다.   
1. 첫 번째 방법은 데이터의 값을 직접 변경하여 데이터를 변형 하는 것입니다.
2. 두 번째 방법은 원하는 변경 사항이 있는 새 복사본으로 데이터를 대체하는 것입니다.
- 최종 결과는 같지만, 원본 데이터를 직접 변형하지 않음으로써 몇 가지 이점을 얻을 수 있습니다.    

1. 불변성을 사용하면 **복잡한 기능을 훨씬 쉽게 구현**할 수 있습니다.   
2. 불변성을 사용하는 것의 **또 다른 장점**이 있습니다.
- 기본적으로 **부모 컴포넌트의 state가 변경되면 모든 자식 컴포넌트가 자동으로 다시 렌더링** 됩니다.
- 여기에는 **변경 사항이 없는 자식 컴포넌트도 포함**됩니다.
- 리렌더링 자체가 **사용자에게 보이는 것은 아니지만,** 성능상의 이유로 **트리의 영향을 받지 않는 부분의 리렌더링을 피하는 것이 좋습니다.**
- 불변성을 사용하면 컴포넌트가 **데이터의 변경 여부를 저렴한 비용으로 판단**할 수 있습니다.

## return의 의미
- 작성한 코드에는 return 값이 없습니다.
- Javascript에서 return값이 없는 return; 은 함수를 즉시 종료하라는 의미입니다.


# 4월 10일 (6주차)

## props를 통해 데이터 전달하기
- React의 component architecture를 사용해서 **재사용할 수 있는 component**를 만들어서 지저분하고 중복된 코드를 삭제합니다.
- **Board component**를 만들고, **Square component의 내용을 복사**합니다.
- **Square component의 button을 하나만 남기고 모두 삭제**합니다.
- Board component의 button을 Square component로 교체합니다.
- App에서 호출하는 component를 Square에서 Board로 바꿔줍니다.
- component를 **호출하는 쪽이 부모 component**입니다.

## state 끌어올리기
- **여러 자식 컴포넌트에서 데이터를 수집**하거나 두 자식 컴포넌트가 **서로 통신**하도록 하려면, **부모 컴포넌트에서 공유 state**를 선언 해야 합니다.
- 부모 컴포넌트는 **props를 통해 해당 state를 자식 컴포넌트에 전달**할 수 있습니다.
- 이렇게 하면 **자식 컴포넌트가 서로 동기화**되고, **부모 컴포넌트와도 동기화**되도록 할 수 있습니다.
- React 컴포넌트를 리팩토링할 때 **부모 컴포넌트로 state를 끌어올리는 것**은 많이 사용하는 방법입니다.

## component 분리하기
- Board component가 export default로 선언된 것을 보면, component가 분리되었다는 것을 알 수 있습니다.

#### [분리 순서]
1. component 이름과 동일한 파일을 만듭니다.
2. 해당 파일에 코드를 복사하고 export default 키워드를 추가합니다.
3. 필요한 component와 useState를 추가합니다.
4. App.js에서 해당 코드를 삭제하고, Board component를 import 해줍니다.
5. App.js에서 useState의 import를 제거합니다.
6. 정상적으로 동작하는지 확인합니다.

# 4월 3일 (5주차)

## 화면 업데이트하기
- component가 **특정 정보를 "기억"해 두었다가 표시**하기를 원하는 경우가 있습니다.
- 예를 들어 **버튼이 클릭된 횟수**를 세고 싶을 수 있습니다.
- 이렇게 하려면 **component에 state를 추가**하면 됩니다.
- 먼저, react에서 **useState를 import**합니다.
- 이 코드를 보면 **useState는 react 파일 안에 Named Exports 로 선언되어 있는 여러 개의 component 중 하나**는 것을 알 수 있습니다. 
- 이제 **component 내부에 state 변수를 선언**할 수 있습니다.
- **useState로부터** 현재의 **state를 저장할 수 있는 변수**인 count와 이를 **업데이트할 수 있는 함수**인 setCount를 **얻을 수 있습니다.**
- **이름은 자유롭게 지정**할 수 있지만, **[something, setSomething] 으로 작성하는 것이 일반적**입니다.
- 즉, **변수 이름과 변수 이름 앞에 set을 붙인 업데이트 함수를 관용적으로 사용**합니다.

## Hook 사용하기
- **use 시작하는 함수**를 Hook이라고 합니다.
- useState는 React에서 제공하는 **내장 Hook**입니다.
- 다른 내장 Hook은 API 참고서에서 찾아볼 수 있습니다.
- 또한 기존의 것들을 조합하여 **자신만의 Hook을 작성할 수도** 있습니다.
- Hook은 **다른 함수보다 더 제한적**입니다.
- component 또는 다른 Hook의 **상단에서만 Hook을 호출**할 수 있습니다.
- 조건이나 반복문에서 useState를 사용하고 싶다면 새 컴포넌트를 추출하여 그곳에 넣으세요.

## Hook의 사용 규칙

- Hook은 React의 **렌더링 및 상태 관리 메커니즘과 밀접하게 연결**되어 있으며, 아래와 같은 규칙을 따라야 합니다.    
1. **최상위에서만 호출**해야 한다.    
-> **if, for, while 등의 블록 내부에서 Hooks를 호출하면 안 됩니다.**    
-> 함수의 조건문 **내부에서 호출하면 실행 순서가 달라질 수 있기 때문**입니다.

2. **React 함수형 component** 또는 **사용자 Hook** **내부에서만 사용 가능**  
-> **일반적인 JavaScript 함수**에서 useState, useEffect 등의 **Hook을 사용할 수 없습니다.**
- 왜 이런 제한이 필요한가?     
: React의 **동작을 예측 가능하고, 안정성을 높이기 위해** 필요한 규칙입니다.

1. rendering 순서를 보장하기 위해      
-> 조건문이나 반복문 안에서 Hooks를 사용하면 매 rendering마다 Hook의 호출 순서가 달라질 수 있기 때문에 React가 상태를 제대로 추적할 수 없습니다.
2. 불필요한 사이드 이펙트 방지      
-> component가 **여러 번 rendering 될 때마다 동일한 순서로 Hook이 실행되어야** React가 **의도한 동작을 수행**할 수 있습니다. 

## 왜 function형 컴포넌트에서만 Hook을 사용할까?
- **Class 형 component는 lifecycle 함수를 통해서 상태 관리**를 했습니다.
- 그런 이유 때문에 **Class형 component는 유지보수가 어렵고 복잡해질 수 있었습니다.**
- React는 component의 **상태 관리(lifecycle)와 로직을 더 간결하게 만들기 위해 Hooks를 도입**하게 됩니다.
- 따라서 React 팀은 **function형 component를 권장하고 있습니다**.
- **Hook은 function형 component 전용으로 설계되었습니다.**

## component 간 데이터 공유
- 사이트에서는 MyButton 으로 설명하고 있지만, 우리는 CountState로 작성했던 것을 기억하고 사이트의 설명을 봐야 합니다.

- 9절에서 "왜 변수는 count 하나인데 버튼 3개의 데이터가 모두 다른 state를 갖는 것일까?"라는 의문이 있었습니다.

- 각각의 CountState component는 독립적인 count가 있는 것 처럼 동작했고, 각 버튼을 클릭하면 클릭한 버튼의 count만 변경되었습니다.

- 그러나 이 것은 이상한 것이 아닙니다. 각 component 객체가 독립적으로 동작하기 때문입니다.

# 3월 27일 (4주차)

## Component의 생성 및 nesting(중첩)
- component는 **고유한 로직과 모양을 가진 UI의 일부**입니다.
- component는 **버튼처럼 작을 수도** 있고, **전체 페이지처럼 클 수도** 있습니다.
- component는 **마크업을 반환(return)하는 JavaScript 함수**입니다.
- **Nesting**은 CSS 선택자의 중첩 구조를 생각하면 쉽게 이해할 수 있습니다.    
-> CSS 중첩 구조는 2023부터 자체 지원합니다. 이전에는 Sass나 Lass등을 이용할 때 사용했습니다. 
- **export default 키워드**는 파일 내의 component 중 **기본 component를 지정**합니다.
- 이 키워드의 사용도 **JavaScript 문법**입니다. 

**[export default와 export의 차이]**

- **Named Exports**(export)   
-> **하나의 파일 안에 여러 개의 component가 있을 때 사용**합니다.    
-> component를 **사용하는 쪽에서는 component 정확한 이름을 반드시 명시**해야 합니다.    
- **Default Export** (export default)    
-> **하나의 파일 안에서 하나의 component만 내보내는 경우 사용**합니다.    
-> component를 **사용하는 쪽에서는 어떤 이름을 사용해도 상관 없습니다.**

## JSX로 마크업 작성하기
- 앞에서 작성한 코드의 **마크업 문법을 JSX라고** 합니다.
- 반드시 사용해야 하는 것은 아니지만, React 프로젝트에서는 **편의성을 위해 JSX를 사용**합니다.
- **JSX는 HTML보다 더욱 엄격한 문법을 적용**합니다.
- JSX에서는 **br 같이 싱글태그라도 태그를 닫아야**합니다.
- React에서는 **여러 개의 component를 JSX태그로 반환할 수** 있습니다.
- 다만 여러 개의 component를 **div 또는 빈 <>..</> wrapping해 줘야** 합니다.

## 스타일 추가하기
- React에서는 **className으로 CSS클래스를 지정**합니다.
- className은 **HTML의 class 속성과 동일한 방식으로 동작**합니다.
- CSS 규칙은 별도의 CSS 파일에 작성합니다. 그런데 React는 **CSS파일을 추가하는 방법을 규정하지는 않습니다.**   
-> 정적 페이지를 작성할 때와 동일한 방법을 지원합니다.
- 가장 간단한 방법은 HTML에  link 태그를 추가하는 것입니다.   
-> 그러나 link를 추가하면 정적 페이지를 수정해야 하기 때문에 **추천하지 않습니다.**    
- 만일 빌드 도구나 프레임워크를 사용한다면 해당 문서를 참고하여 프로젝트에 CSS 파일을 추가합니다.

## 데이터 표시하기
- **JSX를 사용하면 자바스크립트에 마크업을 넣을 수** 있습니다.   
-> **JS안의 마크업 안에 JS를 넣는** 다는 것이 더 정확합니다.
- JSX 코드 내에서 **JavaScript로 "탈출"하여 변수나 표현식을 사용**하는 것입니다.
- 이 방법을 **"Escape Back"**이라고 합니다.
- **{} 중괄호를 사용**해서 변수나 표현식을 사용자에게 표시하도록 하는 것입니다.

## 조건부 렌더링
- React에서 조건문을 작성하는 데에는 특별한 문법이 필요 없습니다.
- **일반적인 자바스크립트 코드를 작성할 때 사용하는 것과 동일한 방법을 사용**합니다.

## 리스트 렌더링하기
- 컴포넌트 **리스트를 렌더링**하기 위해서는 **for문 및 map() 함수**와 같은 자바스크립트 기능을 사용합니다.
- li 에 key 속성(attribute) 이 있는 것을 주목하세요.
- 목록을 사용할 때는 **각 항목에 대해 고유하게 식별하는 문자열 또는 숫자를 전달**해야 합니다.
- **항목을 삽입, 삭제 또는 재정렬할 때** 어떤 일이 일어났는지 알기 위해 **key를 사용**합니다.
- 이것을 **key props**라고 합니다.

# 3월 20일 (3주차)

React 

## React Project의 구조 및 역할
- node_modules/   
-> 초기 node module 및 새로 설치하는 패키지가 저장됩니다.   
-> 초기 파일 37,352 / 폴더 4,597 / 용량은 200MB로 엄청난 양의 파일이 존재합니다.   
-> git으로 관리하지 않기 때문에 디렉토리 이름이 흐릿하게 나와 있는 것을 확인할 수 있습니다. 

- public/   
-> 정적(static) 파일을 저장하는 디렉토리 입니다.   
-> build 후 배포할 html, CSS, JavaScript 등이 보관되는 곳입니다.   
-> 개발하면서 특별히 수정할 코드는 없습니다.

- public/index.html   
->  React 앱이 마운트 되는 HTML 파일.   

- src/   
-> React 프로젝트의 주요 코드가 위치하는 디렉토리 입니다.    
-> 개발하면서 대부분의 작업이 이루어지는 곳입니다.

- src/App.js   
-> 메인 component 로 필요한 sub component 를 모아서 관리합니다.   
-> 출력을 위해서 index.js 로 전달됩니다.

- src/App.css   
-> App.js에 적용되는 스타일을 정의하는 스타일 파일입니다.

- src/index.js   
-> React 앱의 진입 점(entry point)으로 최종 렌더링이 되는 곳입니다.   
-> ReactDOM.createRoot 를 사용하여 App.js를 렌더링합니다.

- src/index.css   
-> 전역 스타일을 정의하는 스타일 파일입니다.

## 의존성 관리와 package.json
- package.json은 **패키지의 의존성을 관리하는 파일**입니다.
- 의존성(Dependency) 이란, 하나의 소프트웨어가 다른 소프트웨어(라이브러리, 패키지, 모듈 등) 에 **의존하여 동작하는 관계**를 말합니다.
- 즉, 어떤 프로젝트에 **사용된 각종 패키지 등의 버전을 동일하게 유지**하기 위한 것입니다.
- **협업**을 할 때는 팀원들 각자의 컴퓨터에 **같은 패키지들을 설치해서 동일한 개발환경을 구성**해야 합니다. 
- **의존성을 무시하면** 다른 버전의 패키지를 설치하는 팀원 때문에 **개발 프로젝트의 오류 등이 발생**할 수 있습니다. 
- **개인**의 경우도 GitHub에 있는 코드를 **내려 받은 후에 동일한 개발 환경을 구성**해야 할 떄가 있습니다. 

## 의존성 관리와 package.json
**[의존성을 관리하는 이유]**
- 손쉬운 설치 및 업데이트   
-> npm install 또는 yarn install 한 줄로 모든 의존성을 자동 설치 가능   
-> 특정 버전의 라이브러리를 쉽게 업데이트 가능

- 일관된 개발 환경 유지   
-> 팀원들과 같은 라이브러리 버전을 유지할 수 있음   
-> package-lock.json을 활용하면 동일한 패키지를 정확한 버전으로 설치 가능 

- 중복 설치 방지   
-> 필요 없는 라이브러리를 제거하여 프로젝트를 가볍게 유지할 수 있음

- package.json은 이런 의존성을 체계적으로 관리하는 역할을 합니다. 

- 프로젝트에 필요한 라이브러리를 쉽게 설치, 업데이트, 유지할 수 있도록 도와주는 시스템입니다. 

## **[package.json의 의존성 내용의 종류]**
- dependencies : **실제 코드에서 사용**하는 라이브러리 (예: React, Express 등)
- devDependencies : **개발할 때만 필요**한 라이브러리들 (예: Webpack, ESLint 등)
- peerDependencies : 필요한 라이브러리만, 직접 설치하지 않고 **사용자에게 설치를 맡기는 경우**
- optionalDependencies : 있어도 되고 없어도 되는 **선택적 의존성**


## **[package.json 과 package-lock.json 차이]**

### - package.json
- **프로젝트의 기본 정보와 의존성을 정의**, 업데이트는 **직접 수정 가능**, 버전 관리는 일반적으로 **^ 또는 ~로 버전 범위를 지정**, 보통 **Git에 포함됨**

### - package-lock.json 
- **설치된 패키지의 정확한 버전 정보 저장**, 업데이트는 의존성 트리 및 패키지의 정확한 버전이 기록됨, 업데이트는 **직접 수정하지 않으며, npm install 시 자동 업데이트**, 버전 관리는 **특정 버전이 고정**되어 일관된 환경 유지 가능, Git 관리는 **포함하는 것이 권장**되지만, node modules/처럼 무시할 수도 있음   

## **[package.json을 유지해야 하는 이유]**

1. **프로젝트의 의존성 정보 제공**
- 프로젝트에서 **어떤 패키지를 사용하는지 정의하는 역할**을 합니다.
- **어떤 패키지를 설치해야 하는지 알 수 있는 기준**이 됩니다.

2. **버전 범위 설정 가능**
- ^18.0.0 처럼 **최신 패치 버전을 허용할 수도** 있고, 18.2.0처럼 **정확한 버전만 고정할 수도** 있습니다. 
- 개발자가 **원하는 방식으로 유연하게 관리**할 수 있습니다.

3. **스크립트와 메타데이터 저장**
- **"script" 속성**을 이용해 **빌드, 테스트, 실행 등의 명령어를 저장**할 수 있습니다.
- **프로젝트 실행을 위해서**는 반드시 필요합니다.

4. 새로운 패키지 설치 및 관리
- **패키지를 설치하면 package.json에 추가**되고, package-lock.json에는 정확한 버전이 기록됩니다. 
- 만약 **package.json이 없으면, 새로운 패키지를 추가할 수 없습니다.**

## node module의 재설치
- node module을 다시 설치해야 하는 경우는 다음과 같은 **3가지 정도의 상황**이 있을 수 있습니다.   
-> **팀 작업**을 하면서 GitHub로부터 프로젝트 파일을 **clone**했을 경우   
-> **개인**이 자신의 프로젝트를 다른 PC 등에서 **clone**을 받아 계속 개발해야 하는 경우   
-> **프로젝트에 문제가 생겨서** node module을 다시 설치해야 하는 경우

**[clone을 받은 프로젝트의 경우]**
1. 다음 명령을 실행하면 package.json과 package-lock.json을 참고하여 패키지를 다시 설치합니다. 
2. node_module 디렉토리는 자동으로 생성됩니다.
3. 설치가 끝나면 프로젝트를 실행시켜서 정상 동작을 확인합니다. 

**[프로젝트에 오류나 의존성 등의 문제가 생겼을 경우]**
1. **node_module 폴더와 package-lock.json 파일 삭제**합니다.   
-> $ rm -rf node_modules package-lock.json
2. npm 패키지의 임시 저장소인 **cache를 초기화**합니다.
- **cache가 오래되면 충돌이 발생할 수도** 있기 때문에 문제 해결에 도움이 될 수 있는 작업입니다.
- **force옵션으로 강제 삭제**합니다.    
-> $ npm cache clean --force

#### **일반적으로 캐시 정리는 안 해도 되지만, 의존성 문제가 계속된다면 실행하는 것이 좋습니다.**
3. 패키지를 다시 설치합니다.   
-> $ npm install
4. 설치가 끝나면 프로젝트를 실행시켜서 정상 동작을 확인합니다. 

**[package-lock.json을 삭제하는 이유]**
1. package-lock.json이 손상되었거나, 잘못된 의존성이 있을 때   
- 가끔씩 package-lock.json이 **의존성 충돌**때문에 이상한 상태가 될 때가 있습니다.    
-> 예를 들면 패키지를 **여러 번 업데이트하면서 충돌이 발생**하는 경우   
-> **수동으로 package.json을 수정**해서 package-lock.json에 영향을 미치는 경우   
- 이런 경우, package-lock.json을 삭제하고 새로 생성하면 충돌이 해결될 수도 있습니다. 

2. **최신 버전의 패키지를 다시 받고 싶을 때**
- **최신 버전의 패키지를 다시 다운로드하고 싶다면**, 삭제하는 것이 효과적입니다.    
- 재설치하면 **최신 버전의 종속성을 기반으로 새로운 package-lock.json이 생성**됩니다.

3. **팀 프로젝트에서 다른 팀원이 이상한 상태로 package-lock.json을 업데이트했을 때**
- 팀원 중 누군가가 **로컬에서 이상한 상태로 package-lock.json을 변경**했다면 파일을 삭제하고 다시 설치하는 것이 더 깨끗할 수도 있습니다. 

#### 문제가 없다면 package-lock.json을 유지하는 것이 좋지만, 의존성 충돌이나 패키지 문제로 인해 에러가 발생한다면 삭제 후 재설치하는 것이 좋습니다.

## React의 핵심 요소 component
**개요**
- React는 **component 단위로 개발하여 레고를 조립하듯이 앱을 완성**합니다.
- component는 **작은 기능을 실행할 수 있는 하나의 모듈**입니다.
- **공식 사이트의 홈**에는 component가 어떻게 사용되는지 설명하고 있습니다. 
- React가 component를 이용하여 어떻게 사용자 인터페이스를 구성하는지 살펴보도록 하겠습니다.
- 이해를 돕기 위해 React코드가 나오지만 **코드 자체를 이해할 필요는 없습니다.**
- React **component가 페이지로 변해가는 과정에 집중**해주세요.
- **React 사이트에 접속**하여 예제 코드를 확인하세요. 
- 사이트에서 **자체 한글을 지원**합니다. **자동 번역은 사용하지 마세요.**
- 왼쪽 **코드에 마우스를 hover**하면, 오른쪽 출력에 어느 부분인지 확인할 수 있습니다. 
- **component의 조립 과정에만 집중해주세요.**

## Component를 사용한 유저 인터페이스 생성
- React 를 사용하면 **component라고 하는 개별 조각으로 사용자 인터페이스를 구축**할 수 있습니다.
- Video, Thumbnail 및 LikeButton 이라는 **react component를 생성**하고, 이 **component를 결합하여 화면과 페이지 그리고 앱 전체를 구성**합니다. 
- **첫 번째 예제는 Video.js**라는 함수형 component입니다.
- **component의 이름**은 파일 이름과 동일하게 하며, 영문 대문자로 시작합니다. PascalCase
- Video component는 Thumbnail과 LikeButton이라는 **두 개의 component를 포함**하고 있습니다.   
**React는 개인, 팀, 조직에서 작성한 component를 원할하게 결합할 수 있도록 설계되었습니다.**

## Component를 작성하는 JavaScript와 Markup
- **React component는 JavaScript 함수**입니다.
- **조건에 따라 화면**을 표시하고 싶다면 **if문을 사용**하면 됩니다. 
- **목록을 표시**하고 싶다면 **map()함수**를 이용하면 됩니다.
- 결국 React를 배우는 것은 프로그래밍을 배우는 것과 같습니다.
- JavaScript를 이미 알고 있다면 더 쉽게 배울 수 있습니다. 

## Component를 작성하는 JavaScript와 Markup
- React에서 사용되는 마크업을 **JSX(Javascript Syntax eXtension)**라고 부릅니다.
- JSX는 React를 통해 대중화된 **JavaScript 확장 문법**입니다.
- JSX 마크업을 관련된 **렌더링 로직과 가까이** 두면, component를 **쉽게 생성, 관리, 삭제** 할 수 있습니다. 

## 필요한 곳에 상호작용 기능 추가
- React component는 **데이터를 수신**하고, 화면에 표시해야 하는 **내용을 반환**합니다.
- **사용자의 입력을 받아** 새로운 데이터를 **component에 전달할 수도** 있습ㄴ디ㅏ. 
- 이때 React는 **상호작용을 통해 얻은 새 데이터로 화면을 업데이트**합니다. 
- 이것은 SearchInput과 VideoList 두 개의 **component를 결합한 또 다른 component**입니다.

## full-stack App 개발을 도와주는 React Framework
- React는 라이브러리이기 때문에 **component를 조합**할 수는 있지만, **라우팅 및 데이터 가져오기 방법 등을 규정하지는 않습니다.**
- React로 **전체 앱을 빌드**하려면 Next.js 또는 Remix와 같은 **full-stack React Framework를 사용**하는 것이 좋습니다.
- 사이트의 confs/[slug].js는 Next.js에서 제공하는 routing 방법 중 하나입니다.
- React도 하나의 **아키텍처**입니다.   
-> 소프트웨어 아키텍처(software architecture)는 **소프트웨어의 구성 요소들 사이에서 유기적 관계를 표현**하고 **소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙**
- 따라서 이를 구현하는 **Framework를 사용**하면, **서버에서 실행되거나 혹은 빌드 중에도 비동기 component에서 데이터를 가져올 수도** 있습니다.
- 또한 **파일이나 데이터베이스에서 데이터를 읽어**와서 **대화형 component에 전달할 수도** 있습니다.

## 모든 플랫폼에서 최고의 성능을 발휘하는 React
- React를 사용하면 **동일한 기술을 사용**하여, **웹 앱과 네이티브 앱을 모두 구축**할 수 있습니다. 
- **각 플랫폼의 고유한 강점을 활용**하여, **모든 플랫폼 잘 어울리는 인터페이스를 구현**할 수 있습니다.   


**[웹의 본질에 충실하기]**
- 사람들은 웹 앱 페이지가 **빠르게 로드되기를 기대**합니다.
- React를 사용하면 **서버에서 데이터를 가져오는** 동안에도 **HTML을 스트리밍 시작할 수** 있기 때문에, **JavaScript 코드가 로드되기 전에 콘텐츠를 점진적으로 채울 수** 있습니다.
- 또한 **클라이언트 측에서는 표준 웹 API를 사용해서**, **렌더링 도중에도 UI를 반응하도록 할 수** 있습니다. 
- 이런 동작들은 사람들이 원하는 빠른 렌더링을 도와줍니다.   

**[진정한 네이티브 UX를 실현]**
- 사람들은 네이티브 앱이 **자신의 플랫폼과 같은 모양과 느낌**을 주기를 원합니다.
- **React Native와 Expo를 사용**하면 **Android,iOS 등을 위한 앱을 React로 빌드**할 수 있습니다.
- 앱이 **네이티브처럼 보이고, 느껴지는 이유는 UI가 네이티브이기 떄문**입니다.
- 즉 **Web View가 아니라** 플랫폼에서 제공하는 **Android 및 iOS View를 사용**하기 때문입니다.
- React를 사용하면 **웹 개발자도 네이티브 개발자도 될 수** 있습니다. 
- **사용자 경험의 희생 없이 다양한 플랫폼에 앱을 출시** 할 수 있습니다.
- 기업에서는 플랫폼 간의 장벽을 허물고, **전체 기능을 협업을 통해 개발할 수 있는 팀을 구성**할 수 있습니다.

## 새로운 기능에 맞춰 업그레이드 하기
- React는 변화에 신중하게 접근합니다.
- 모든 React commit은 **10억명 이상의 사용자에 의해 여러 환경에서 테스트**를 거쳤습니다.
- Meta에 있는 10만개 이상의 React component는 **모든 마이그레이션 전략의 검증을 지원**합니다.   
-> 마이그레이션이란 데이터나 소프트웨어를 **한 시스템에서 다른 시스템으로 이동**하는 것.
- React 팀은 항상 React를 개선하는 방법을 연구합니다.

# 3월 13일 (2주차)

## Node.js의 활용
- 웹 서버    
-> REST API, GraphQL API 개발  
- 실시간 애플리케이션  
->채팅, 실시간 알림, 스트리밍   
- 서버리스 환경   
->AWS Lambda 같은 Faas(Function as a Service)

## Node.js 인기 이유
- 빠른 성능 : V8 엔진 기반 + 비동기 논 블로킹 방식으로 고성능 처리 가능   
- JavaScript 풀스택 개발 : 프론트엔드와 백엔드를 같은 언어(JavaScript) 로 개발 가능   
- 활발한 생태계 : npm을 통해 다양한 패키지 사용이 가능   
- 실시간 애플리케이션에 강함 : WebSocket, Socket.io 지원
- 마이크로 서비스 및 서버리스 환경과의 조화로운 연동

## Node.js 는 앞으로도 계속 발전할까?
- Node.js의 창시자가 만든 Deno가 경쟁자로 떠오르고 있지만, Node.js의 생태계가 훨씬 크고 안정적임
- ES 모듈로의 전환 진행 중
- AWS, Azure, GCP에서 Node.js 지원 강화

## Node.js 의 장단점   
### 장점
- 비동기 논 블로킹 I/O로 높은 성능 제공   
- JavaScript 풀스택 개발이 가능하여 생산성이 향상됨   
- npm의 방대한 생태계를 활용 가능   
- 경량 서버 개발에 적합 (Express.js 등)   
- 실시간 데이터 처리(WebSocket)가 강력함
### 단점
- CPU 집약적인 작업에 부적합   
> 싱글 스레드 기반이라 멀티스레딩 성능이 부족   
- 콜백 지옥(Callback Hell) 문제
> 해결책으로 async/await과 Promise 사용
- 보안 취약점
> npm 패키지의 보안 문제가 자주 발생




